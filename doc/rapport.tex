\documentclass[a4paper,12pt]{article}
\usepackage{général}
%
\usepackage[french]{babel}
% \usepackage[margin=3cm,tmargin=5cm,bmargin=3.5cm]{geometry}
\usepackage{color}
\usepackage[indent=.7cm]{parskip}

\usepackage{float} % forcer impérativement le placement d’un flottant (figure ou table)

\newcommand\refsuscrite[1]{\textsuperscript{\ref{#1}}}

\title{
    \begin{figure}[!t]
	\begin{minipage}{.25\textwidth}
	    \includegraphics[width=\textwidth]{img/logo_lmu.png}
	\end{minipage}
	\hspace{.5\textwidth}
	\begin{minipage}{.25\textwidth}
	    \includegraphics[width=\textwidth]{img/logo_ic2.png}
	\end{minipage}
    \end{figure}
    \begin{center}
	\textbf{\textcolor{blue}{Le Mans Université}} \\
	Licence informatique 2\textsuperscript{e} année \\
	Module 174UP02 – Rapport de projet \\
	\textbf{Dig \& Rush}
    \end{center}
}
\author{
	\begin{tabular}{rl}
	    Matthieu & \textsc{Boulanger} \\
	    Ania & \textsc{Garoui} \\
	    Yohan & \textsc{Harison} \\
	    Jacques-Gérard & \textsc{Mpondo Toutou}
	\end{tabular}
}
\date{\today}


% plan Piau-Toffolon
% introduction
% analyse et conception
%	présentation du jeu −> principales fonctionnalités du jeu (haut niveau)
%       principales structures de données
% réalisation/développement
%       architecture du jeu (schéma fichiers), tableau principaux fichiers


\begin{document}

\maketitle
\begin{center}
    \href{https://github.com/idlusen/dig-and-rush/}{Lien vers le dépôt du projet}
\end{center}
\newpage

\tableofcontents
\newpage

% \abstract{Ceci est le texte de mon résumé...}

\section{Introduction}
% Rédaction : Yohan
% Longueur : 1 page

Les objectifs de ce projet en groupe sont de mettre en pratique nos connaissances acquises durant cette deuxième année de licence informatique, notamment en algorithmique en code C.
Ce projet permet également de nous introduire à la gestion de projet qui nous sera utile dans le monde professionnel. 
Enfin, il permet de commencer à agir en groupe et en autonomie, deux points qui nous seront également utiles en tant que professionnels.

Le principe du jeu Dig \& Rush consiste à l’instar du jeu Once upon a tower, jeu mobile, de descendre dans une tour en creusant des blocs qui font office de murs et de sols comme dans un labyrinthe. 
Le joueur a pour outil une pelle qui lui permet de détruire les blocs. 
Il faut en plus de cela éviter ou tuer les ennemis afin de progresser le plus rapidement dans la tour. 
Si le personnage meurt la partie se termine. Le joueur a le choix entre plusieurs personnages qui ont chacun une particularité.
Attention, chaque tour est différente ! Cela vous permet d’explorer à chaque nouvelle partie une nouvelle facette du jeu.

Ce rapport se déroule en quatre parties. 
L’organisation du projet, comment les tâches ont été définies et attribuées ; la conception, qui présentera nos choix de conception et les règles du jeu ; le développement avec les outils utilisés, les sturctures de données et les algorithmes et enfin la conclusion qui mettra en avant nos remarques, nos points d’amélioration et ce que nous avons tiré de ce projet. 
En annexe, se trouvera les tests unitaires et tentatives de debogage, les captures d’écran du jeu et les diagrammes de Gantt.

\newpage
\section{Organisation}
% Rédaction : Yohan, Jacques
% Longueur : 2 pages
% Sujets : Gantt, répartition des tâches, salon de discussion, github (cartes ?), trello


\subsection{Définition des tâches}
Avant de commencer à coder l’équipe a effectué un brainstorming afin de connaître toutes les phases du projet et les tâches qui seraient susceptibles d’entrer dans ces dernières. 
En effet, en citant exhaustivement les tâches cela nous permet d’avoir une estimation temporelle du projet. 
Nous avons également pris en compte les attentes du corps enseignant.

Nous avons détecté 7 phases principales sur le projet général : la définition du projet, la planification, la conception et l'analyse, la phase de réalisation, la phase de documentation, le rapport du projet et la soutenance qui font parti de la phase de livraison.

La définition du projet est l’étape post conception elle permet de faire une esquisse du projet et ainsi se le représenter plus facilement. 
On y détermine les limites du projet. 
La conception entre dans l’architecture du projet. 
La planification, qui sera évoquée dans la partie suivante, sert à se répartir les tâches. La phase de réalisation est le codage ainsi que les tests. 
La documentation est la création de documents permettant la compréhension du projet. 
Le rapport et la soutenance sont réservés à la présentation du projet.

\subsection{Répartition des tâches}
Suite à l’élaboration de la liste des tâches nous nous sommes réparties les tâches en fonction de deux critères. 
Tout d’abord les choix et affinités de chacuns, en effet chaque personne du groupe a préféré certaines tâches plutôt que d’autres. 
Ensuite, nous nous sommes réparties le reste des tâches en équilibrant afin que tout le monde ait à peu près le même temps de travail.

Pour rendre visuel ces deux étapes précédentes l’équipe utilise l'outil GANTT. 
Il s’agit d’un graphe qui représente les tâches étalées sur le temps. 
Google Sheet est utilisé afin de pouvoir le mettre à jour et collaborer à distance.
Sur le graphe sont présentes les tâches, les dates encadrantes ces dernières et une représentation graphique de la durée de la date entre la semaine du 8 janvier 2024 et celle du 22 avril 2024.
L’équipe adopte deux diagrammes de Gantt, un diagramme prévisionnel qui représente l’avancement idéal du projet et un diagramme réel qui est mis à jour régulièrement. 
Ce dernier sert principalement à voir les tâches restantes en fonction de la deadline.

\subsection{Outils consacrés à la communication et à l'organisation}
Nous utilisons Discord pour communiquer. 
Il permet de créer des canaux en fonction de nos besoins. 
Dans le cas de projet il y a un canal pour les ressources, un pour la conversation générale et des canaux vocaux si nous avons besoin de nous appeler. 
Nous utilisons principalement le canal général pour suivre l’avancement de chacun.

\begin{figure}[h]
\begin{center}
\includegraphics[height=4cm]{img/capture_trello.png}\\
\caption{{\emph{Mettre capture Discord}}}
\label{discord}
\end{center}
\end{figure}

Sur le mois d’avril un Trello est mis en place, il a permis de voir plus facilement les tâches restantes et de les prioriser. 
Dans ce Trello est présent huit listes pour : les ressources, les idées, ce qu’il faut faire mais qui n’est pas urgent, ce qu’il faut faire, les tâches en cours, celles terminées, les problèmes et enfin ce qu’il ne faut pas oublier. 
Contrairement au diagramme de Gantt, il se concentre principalement sur les tâches liées au codage.

\begin{figure}[h]
\begin{center}
\includegraphics[height=7cm]{img/capture_trello.png}\\
\caption{{\emph{Une partie du Trello}}}
\label{trello}
\end{center}
\end{figure}

Afin de gérer les différentes versions du code sources, Git est utilisé. 
Il permet d’avoir un espace de stockage commun que ce soit pour la documentation que le code. De plus, cela permet à chacun de travailler sur une partie du projet sans modifier ce que font les autres membres du groupe, notamment grâce à la création de branches qui permet la création un clone du code principal et pouvoir travailler dessus. 
A peu près une branche a été créée pour chaque fonction principale du jeu. Une fois le code respectif fonctionnel nous le fusionnons dans le code principal.

En plus du diagramme de Gantt et du Trello l’équipe utilise l’outil “Projects” dans Git. 
Il sert, dans le cas de ce projet, à communiquer notre avancement au corps enseignant. 
Il permet également, pour chaque semaine, de mettre la tâche effectuée par chaque membre de l’équipe.



\section{Conception}
% Rédaction : Yohan, Ania
% Longueur : 3 pages
% Sujets : analyse, cahier des charges etc.

Développé en C en utilisant la bibliothèque SDL, notre jeu a d'abord connu une phase de conception.

\subsection{Objectif du jeu}
Il n’y a pas de fin au jeu, l’objectif est  donc d’avoir le plus de points avant de mourir.

\subsection{Règles du jeu}
Il y a trois règles principales dans le jeu :
\begin{itemize}
	\item Il faut creuser les blocs de terre pour descendre dans la tour et éviter les ennemis.
	\item Il est possible de tuer les ennemis pour ajouter des points au score et éviter de se faire tuer.
	\item Il faut éviter de se prendre des coups des ennemis pour ne pas perdre des points.
	\item Il ne faut pas perdre de temps car on perd des points au fil du temps même sans se faire attaquer par des ennemis. 
\end{itemize}

\subsection{Graphismes}
%  Rédigé par : Ania
Les graphismes de Dig\&Rush sont fortement inspirés du jeu mobile Once Upon a Tower.
Pour les menus (menu principal, menu de personnages, menu de paramètres, \dots), les couleurs  chaudes telles que le rouge et le orange, mixé à une pointe de violet nous semblaient plus adaptés à l'esprit combatif et dangereux du jeu. 
En ce qui concerne l'interface du jeu, nous avons opté pour une palette de couleurs vivantes dans les tons bleu, vert et blanc pour attirer et retenir l'attention des joueurs.
Une fois les couleurs définies, il nous restait à trouver les bonnes ressources en libre de droit. Nous avons donc fini par opter pour des images d'intérieur médiéval pour les menus, un fond de ciel bleu pour l'interface de jeu et un fond uni blanc pour le fond de la tour.
La tour elle à son tour, est entourée de murs de blocs de pierres.
\begin{figure}[h]
	\begin{center}
		\includegraphics[height=7cm]{img/menu.png}\\
		\caption{{\emph{Menu principal}}}
		\label{menu}
	\end{center}
\end{figure}

\subsection{Niveaux}
%  Rédigé par : Ania
Les niveaux, avec le placement des blocs qui devait être aléatoire, était l'une des parties les plus complexes à concevoir, car il nous fallait pour chaque ligne une suite de blocs de pierres, de blocs de terre et de vides générés automatiquement mais tout en faisant attention à toujours laisser au moins une issue possible au joueur afin qu'il puisse avancer.

\subsection{Personnages}
Sur l’aspect graphique, les personnages s’inspirent des jeux en pixel art. 
Il y  a deux catégories de personnages : les personnages qu’il est possible de jouer et les ennemis nommés PNJ.
L’ennemi se déplace de gauche à droite et inversement sur son niveau. 
Lorsqu’ils rencontrent notre personnage ils se mettent à attaquer, ce qui tue le personnage ou non en fonction de ses points de vie. 
Actuellement il y a deux types d’ennemis : les squelettes et les boules de feu vivantes. 
Ces deux PNJ ont deux portées d’attaques différentes, la boule de feu doit être davantage en contact avec le personnage pour attaquer.

\begin{figure}[h]
	\begin{center}
		\includegraphics[height=3cm]{img/exemple_feu.png}\\
		\caption{{\emph{Ennemi de type boule de feu}}}
		\label{boule de feu}
	\end{center}
\end{figure}

Il y a trois personnages jouables qui représentent chaque membre de l’équipe. 
Ces derniers ont chacun une caractéristique spécifique (vie plus conséquente,vitesse accrue, ou non). 
Ils peuvent se diriger à gauche, à droite et vers le bas en fonction de la touche appuyée. 
Les personnages jouables doivent également pouvoir creuser le sol et les murs. Il est donc nécessaire d’avoir des sprites qui possèdent ces animations de déplacement et de creusage.
Pour ces derniers, nous avons utilisé un générateur de sprite où il était possible de personnaliser nos personnages. Nous les avons donc adaptés aux quatres membres. 
Pour les ennemis un autre site, libre de droit, est utilisé afin de les différencier davantage.

\begin{figure}[h]
	\begin{center}
		\includegraphics[height=3cm]{img/exemple_personnage_jouable.png}\\
		\caption{{\emph{Personnage jouable}}}
		\label{personnage jouable}
	\end{center}
\end{figure}


\subsection{Mécaniques}
%  Rédigé par : Ania
Comme mentionné précédemment, notre jeu est composé d'une tour, de blocs de pierres, de terre, de personnages (joueurs et non joueurs) et le petit plus : un effet de transition entre le jour et la nuit.
\begin{itemize}
	\item Les blocs de pierres délimitent la tour et les endroits par où le joueur ne peut pas passer.
	\item Les blocs de terre sont destructibles et permettent donc de creuser un chemin pour le joueur, mais non pour le PNJ.
	\item Les personnages joueur creusent et attaquent les ennemis pour les vaincre.
	\item Les personnages non-joueur (ennemis) se déplacent sur un axe horizontal et attaquent le joueur dès qu'il est détécté à leur proximité.
	\item Effet d'ombre qui permet la transition entre le jour et la nuit pour varier la difficulté et rajouter du défi.
\end{itemize}

Chacune de ces mécaniques est agrémenté d'un son pour soit un joueur masculin ou féminin (son de blessure, d'attaque, de mort, ...).


\subsection{Analyse des difficultés}
% Difficulté de savoir quel types de structures utiliser : listes, matrices, ...
% Communication, gestion, ...



\section{Développement}
% Rédaction : Matthieu, Ania, Jacques
% Longueur : 5 pages
% Sujets : librairies, architecture du code, menu, personnages, tour, blocs, documentation etc.

Dans cette section, nous traitons des aspects techniques du développement de notre jeu en 2D utilisant la bibliothèque SDL et programmé en langage C. Elle englobe plusieurs sujets, notamment les librairies employées, l'architecture du code, la création des personnages...

\subsection{Librairies et outils utilisés}

Pour le développement de notre jeu, nous avons principalement opté pour l'utilisation de la bibliothèque SDL (Simple DirectMedia Layer) en langage C. SDL s'est révélée être un choix judicieux, offrant une interface simple et efficace pour la gestion des graphiques, du son et des périphériques d'entrée. Cette bibliothèque a grandement facilité le processus de développement de notre jeu en 2D. En complément, nous avons intégré GitHub comme plateforme de gestion de version, nous permettant ainsi de collaborer efficacement sur le code source et de suivre son évolution au fil du temps. De plus, nous avons utilisé des outils de développement standard tels que GCC (GNU Compiler Collection) pour la compilation du code source et GDB (GNU Debugger) pour le débogage.

\subsection{Création des personnages}



\subsection{Architecture du code}

\begin{table}[H]
    \centering
    \begin{tabular}{c p{.6\textwidth}}
	\toprule
	\texttt{main.c}			    & point d’entrée du programme	\\
	\midrule
	\texttt{ressources.c}		    & fonctions et structures de chargement des fichiers de ressources	\\
	\midrule
	\texttt{tour.c}			    & cœur du jeu avec notamment la boucle principale	\\
	\midrule
	\texttt{entite.c}                   & structure utilisée pour tout objet devant être affiché, déplacé et animé  \\
	\midrule
	\texttt{entite\_obstacle.c}          & spécialisation des entités qui agissent comme obstacles  \\
	\midrule
	\texttt{entite\_destructible.c}	    & spécialisation des entités qui peuvent être détruites \\
	\midrule
	\texttt{entite\_pnj.c}		    & spécialisation des entités représentant un personnage non joueur	\\
	\midrule
	\texttt{entite\_perso.c}		    & spécialisation des entités représentant le personnage du joueur	\\
	\midrule
	\texttt{texte.c}		    & API\refsuscrite{def_api} pour simplifier la gestion des textes   \\
	\midrule
	\texttt{nuit.c}			    & structure et fonctions implémentant une transition jour/nuit \\
	\bottomrule
    \end{tabular}
    \caption{Rôle des différents modules}
\end{table}

\section{Conclusion}
% Rédaction : Jacques, Matthieu
% Longueur : 1 page et demi

La conclusion de ce projet met en lumière les apprentissages, les défis surmontés et les perspectives pour l'avenir. Nous avons réussi à concrétiser notre vision du jeu Dig \& Rush grâce à une collaboration efficace et à une répartition équilibrée des tâches. En utilisant des outils tels que Discord, Trello et Git, nous avons pu organiser notre travail de manière transparente et coordonnée, facilitant ainsi la communication et la gestion des versions du code.



% Annexes
\newpage
\appendix

\section{Lexique}

\begin{table}[h]
    \centering
    \begin{tabular}{c p{.6\textwidth}}
	\toprule
	PNJ		    & Personnage Non Joueur \\
	\midrule
	API \label{def_api} & \textit{Application Programming Interface}, ensemble de classes et fonctions servant d’interface vers un service \\
	\bottomrule
    \end{tabular}
    \caption{Définitions des termes techniques employés dans le document}
\end{table}



\section{Tests unitaires}
% Rédigé par : Ania
Les tests unitaires sont essentiels pour assurer la qualité et la fiabilité. Parmis les différentes fonctions implémentées, il nous a semblé important de vérifier le bon fonctionnement grâce à une suite de tests disponibles sur la librairie CUnit.\\
Fonctions testées : init\_ressources, recuperer\_texture, recuperer\_spritesheet, recuperer\_son, recuperer\_musique, recuperer\_audio, recuperer\_police, jouer\_audio et detruire\_ressources.\\
Voici le résultat des tests disponibles dans le fichier test\_unit.c\\

\begin{figure}[h]
	\begin{center}
		\includegraphics[height=7cm]{img/capture_tests.png}\\
		\caption{{\emph{Résultats des tests unitaires}}}
		\label{tests}
	\end{center}
\end{figure}

Les résultats des cinq assertions sont logiques et indiquent que les fonctions se comportent comme prévu, ce qui signifie que les ressources sont fiables.\\
Nous avons jugé important de mettre en place une suite de tests unitaires efficace qui présente une bonne base pour ajouter plus de tests au fur et à mesure que le projet s'agrandit. Cela aide au maintient de la qualité du code tout au long du développement.
\section{Exemple de débogage}
Lors du développement du jeu, plus précisément de la fonction de génération d'ennemis, un bug revenait souvent : un ennemi était généré dans le vide. Pour régler ce problème, il a donc fallu déboger.\\
La fonction en question (\textit{generer\_ennemi(x,y)} ) est déclarée et appelée dans le fichier source \textit{src/morceaux\_niveau.c.}\\
\begin{figure}[h]
	\begin{center}
		\includegraphics[height=7cm]{img/bug.png}\\
		\caption{{\emph{Bug du squelette}}}
		\label{Bug}
	\end{center}
\end{figure}
Etapes de débogage : 
\begin{itemize}
	\item Lancer GDB
	\item Poser un point d'arrêt (\textit{(gdb) break src/morceaux\_niveau.c:generer\_ennemi}).
	\item Appuyer sur \textit{PLAY}.
	\item On avance dans le jeu jusqu'à rencontrer le point d'arrêt.
	\item On execute \textit{step} pour rentrer dans l'appel de fonction.
	\item A l'aide des options de débogages telles que textit{print, display, next, \dots}, nous avons constaté que l'algorithme de base n'était pas bon.
\end{itemize}
\begin{figure}[h]
	\begin{center}
		\includegraphics[height=7cm]{img/debug.png}\\
		\caption{{\emph{Exemple de débogage}}}
		\label{débogage}
	\end{center}
\end{figure}
Note : les instruction de débogage sont renseignées dans le manuel d'installation et d'utilisation fourni.

% Bibliographie
% \newpage
% \begin{thebibliography}{REF}
%     \bibitem{apa_scribbr}\url{https://www.scribbr.fr/category/normes-apa/}
%     \bibitem{apa_umontreal}\url{https://bib.umontreal.ca/citer/styles-bibliographiques/apa?tab=3281} 
%     \bibitem{wikibooks}\url{https://fr.wikibooks.org/wiki/LaTeX/Tableaux}
%     \bibitem{zestedesavoir}\url{https://zestedesavoir.com/tutoriels/826/introduction-a-latex/1322_completer-vos-documents/images-tableaux-et-texte-preformate/#2-tableaux}
% \end{thebibliography}

\end{document}
